<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Mini 3D CAD</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #toolbar {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 1;
      background: rgba(255,255,255,0.8);
      padding: 8px;
      border-radius: 4px;
    }
    .tool-button {
      padding: 6px 10px;
      margin-right: 5px;
      cursor: pointer;
    }
    .tool-button.active {
      background-color: #0a84ff;
      color: white;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button class="tool-button active" id="boxTool">박스</button>
    <button class="tool-button" id="selectTool">선택/이동</button>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/examples/js/controls/OrbitControls.js"></script>
  <script>
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(50, 50, 50);
    camera.lookAt(scene.position);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // 바닥 그리드
    const grid = new THREE.GridHelper(100, 20);
    scene.add(grid);

    // 조명
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const directional = new THREE.DirectionalLight(0xffffff, 0.8);
    directional.position.set(50, 100, 50);
    scene.add(directional);

    let currentTool = 'box';
    const toolButtons = document.querySelectorAll('.tool-button');
    toolButtons.forEach(btn =>
      btn.addEventListener('click', () => {
        currentTool = btn.id === 'boxTool' ? 'box' : 'select';
        toolButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      })
    );

    let selectedObj = null;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('mousedown', (e) => {
      mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      if (currentTool === 'box') {
        const geometry = new THREE.BoxGeometry(10, 10, 10);
        const material = new THREE.MeshLambertMaterial({ color: 0x2194ce });
        const box = new THREE.Mesh(geometry, material);
        const intersect = raycaster.intersectObject(grid, true)[0];
        if (intersect) {
          box.position.copy(intersect.point).add(new THREE.Vector3(0, 5, 0));
        }
        scene.add(box);
      } else if (currentTool === 'select') {
        const intersects = raycaster.intersectObjects(scene.children, true);
        selectedObj = intersects.length > 0 ? intersects[0].object : null;
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (selectedObj && currentTool === 'select') {
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersect = raycaster.intersectObject(grid, true)[0];
        if (intersect) {
          selectedObj.position.copy(intersect.point).add(new THREE.Vector3(0, selectedObj.geometry.boundingBox.getSize(new THREE.Vector3()).y/2, 0));
        }
      }
    });

    window.addEventListener('mouseup', () => selectedObj = null);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
